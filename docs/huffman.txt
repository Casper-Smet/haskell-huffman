-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/Casper-Smet/haskell-huffman/blob/master/README.md</a>
@package huffman
@version 1.0.0.0


-- | This module contains all necessary functions to encode to and decode
--   from Huffman codes. This module was created for the Utrecht University
--   of Applied Sciences AI course 'Declarative Programming'
module Lib

-- | The <a>countValues</a> function counts each unique character in a
--   string. Adapted from <a>https://stackoverflow.com/a/3711137</a>.
countValues :: String -> [(Char, Int)]

-- | The <a>createNodes</a> function creates a Node for each tuple. The
--   frequency of a character equals its Weight.
createNodes :: [(Char, Int)] -> [HuffmanTree]

-- | The <a>createTree</a> function recursively creates one HuffmanTree
--   from a list of HuffmanTrees. | It merges the two HuffmanTree with the
--   lowest Weight, adds them to the list of HuffmanTrees and repeats until
--   only one tree is left
createTree :: [HuffmanTree] -> HuffmanTree

-- | The <a>encodeTree</a> function traverses (Depth First) a HuffmanTree.
--   It then creates a code for each Node (or Leaf) Each time it goes left,
--   it adds O to the path, every time it goes right it adds I to the path.
--   When it reaches a Node, it returns a tuple containing the character
--   and the path (the path needs to be reversed to be traversable in
--   decoding).
encodeTree :: HuffmanTree -> [(Char, [Binary])]

-- | The <a>encodeString</a> function completes Huffman Encoding on text
--   using a Map (see <a>encodeTree</a> and subsequently <a>tupleToMap</a>)
encodeString :: String -> Map Char [Binary] -> [Binary]

-- | The <a>decodeList</a> function decodes a Huffman code using Huffman
--   Codes in the form of a Map. | Tries to find keys in the inputted list.
--   If it cannot, it errors out.
decodeList :: [Binary] -> Map [Binary] Char -> String

-- | The <a>tupleToMap</a> function is a wrapper for Data.Map.fromList.
--   This is necessary for encoding the original text.
tupleToMap :: [(Char, [Binary])] -> Map Char [Binary]

-- | Returns a Haskell encoded String Composition of <a>encodeString</a>,
--   <a>tupleToMap</a>, <a>encodeTree</a>, <a>createTree</a>,
--   <a>createNodes</a> and <a>countValues</a>
codedString :: String -> [Binary]

-- | The <a>mergeNodes</a> function merges two HuffmanTree's into one
--   Branch. | The weight of the new Branch being the sum of the weight of
--   it's predecessors.
mergeNodes :: HuffmanTree -> HuffmanTree -> HuffmanTree

-- | Binary datatype, uses I and O
data Binary

-- | Binary 1
I :: Binary

-- | Binary 0
O :: Binary

-- | HuffmanTree datatype, uses Node and Branch and branch constructors.
--   HuffmanTrees are compared by weight.
data HuffmanTree

-- | The Node (alternatively, the Leaf) is a type of HuffmanTree containing
--   a Char and a Weight.
Node :: Char -> Int -> HuffmanTree

-- | The Branch is a type of HuffmanTree containting two other
--   HuffmanTreess and the sum of the weight of these HuffmanTreess.
Branch :: HuffmanTree -> HuffmanTree -> Int -> HuffmanTree
instance GHC.Classes.Eq Lib.HuffmanTree
instance GHC.Show.Show Lib.HuffmanTree
instance GHC.Classes.Eq Lib.Binary
instance GHC.Classes.Ord Lib.Binary
instance GHC.Show.Show Lib.Binary
instance GHC.Classes.Ord Lib.HuffmanTree


-- | This module contains helper functions for encoding and decoding to
--   file. Actual writing to file only happens in the application side of
--   this library This module was created for the Utrecht University of
--   Applied Sciences AI course 'Declarative Programming'
--   
--   There are a couple of references to 'delimiter1' and 'delimiter2'.
--   These are defined as follows:
--   
--   <ul>
--   <li>delimiter1 = "||"</li>
--   <li>delimiter2 = "#|"</li>
--   </ul>
module HFIO

-- | Takes a string containing 'I' or 'O's, returns list of Binary.
keyFromString :: String -> [Binary]

-- | Reshapes Huffman Map
reshapeCodes :: [(Char, [Binary])] -> [(Char, String)]

-- | Takes a list of Huffman Key-Value pairs, turns into String for
--   printing to file. Uses delimiter1 and delimiter2.
formatCodes :: [(Char, String)] -> String

-- | Inverse of <a>formatCodes</a> using lists instead of tuples
listifyCodes :: String -> [[String]]

-- | Takes two-dimensional list, returns tuple pair (Huffman Map)
readCodes :: [[String]] -> [([Binary], Char)]

-- | Composition of <a>readCodes</a> and <a>listifyCodes</a>
readCodeString :: String -> [([Binary], Char)]
